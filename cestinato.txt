void MatchingMethod(int, void *)
{
    Mat img_display;
    img_tm.copyTo(img_display);
    for (int i = 0; i < templ_tm.size(); i++)
    {
        int result_cols = img_tm.cols - templ_tm[i].cols + 1;
        int result_rows = img_tm.rows - templ_tm[i].rows + 1;
        result_tm.create(result_rows, result_cols, CV_32FC1);
        matchTemplate(img_tm, templ_tm[i], result_tm, TM_SQDIFF);
        normalize(result_tm, result_tm, 0, 1, NORM_MINMAX, -1, Mat());
        double minVal;
        double maxVal;
        Point minLoc;
        Point maxLoc;
        Point matchLoc;
        minMaxLoc(result_tm, &minVal, &maxVal, &minLoc, &maxLoc, Mat());
        matchLoc = minLoc;
        // cout << minVal << endl;
        rectangle(img_display, matchLoc, Point(matchLoc.x + templ_tm[i].cols, matchLoc.y + templ_tm[i].rows), Scalar(0, 0, 255), 2, 8, 0);
        rectangle(result_tm, matchLoc, Point(matchLoc.x + templ_tm[i].cols, matchLoc.y + templ_tm[i].rows), Scalar(0, 0, 255), 2, 8, 0);
        cv::putText(img_display, labels[i], cv::Point(matchLoc.x, matchLoc.y - 10), cv::FONT_HERSHEY_SIMPLEX, 0.9, cv::Scalar(0, 0, 255), 2);
        imshow(image_window, img_display);
        imshow(result_window, result_tm);
    }
    return;
}

// Template Matching
bool use_mask = false;
cv::Mat img_tm, templ_1, templ_2, templ_3;
std::vector<cv::Mat> templ_tm;
std::vector<std::string> labels;
Mat mask;
Mat result_tm;
const char *image_window = "Source Image";
const char *result_window = "Result window";
int match_method;
int max_Trackbar = 5;


static void CannyThreshold(cv::Mat &in1, cv::Mat &in1_gray)
{
    cv::cvtColor(in1, in1_gray, cv::COLOR_BGR2GRAY);
    cv::GaussianBlur(in1_gray, dst, cv::Size(kernel_size, kernel_size), 0, 0);
    cv::Canny(dst, detected_edges, lowThreshold, max_lowThreshold);
    dst = cv::Scalar::all(0);
    in1.copyTo(dst, detected_edges);
    cv::imshow(window_name, dst);
}





// create k masks and initialize to zeros
std::vector<cv::Mat> masks(k);
for (int i = 0; i < k; i++)
    masks[i] = cv::Mat::zeros(src.size(), CV_8U);

// colors pixels to 255
for (int i = 0; i < src.rows * src.cols; i++)
    masks[labels[i]].at<uchar>(i / src.cols, i % src.cols) = 255;

// creates vector of k result image, 1 for each cluster
std::vector<cv::Mat> results(k);
for (int i = 0; i < k; i++)
    src.copyTo(results[i], masks[i]);

return results;
}